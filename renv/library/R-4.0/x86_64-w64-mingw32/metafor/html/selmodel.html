<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Selection Models</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for selmodel {metafor}"><tr><td>selmodel {metafor}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Selection Models</h2>

<h3>Description</h3>

<p>Function to fit selection models. <script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
</p>


<h3>Usage</h3>

<pre>
selmodel(x, ...)

## S3 method for class 'rma.uni'
selmodel(x, type, alternative="greater", prec,
         delta, steps, verbose=FALSE, digits, control, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>an object of class <code>"rma.uni"</code>.</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p>character string to specify the type of selection model. Possible options are <code>"beta"</code>, <code>"halfnorm"</code>, <code>"negexp"</code>, <code>"logistic"</code>, <code>"power"</code>, <code>"negexppow"</code>, or <code>"stepfun"</code>. Can be abbreviated. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>alternative</code></td>
<td>
<p>character string to specify the sidedness of the hypothesis when testing the observed outcomes. Possible options are <code>"greater"</code> (the default), <code>"less"</code>, or <code>"two.sided"</code>. Can be abbreviated.</p>
</td></tr>
<tr valign="top"><td><code>prec</code></td>
<td>
<p>optional character string to specify the measure of precision (only relevant for selection models that can incorporate this into the selection function). Possible options are <code>"sei"</code>, <code>"vi"</code>, <code>"ninv"</code>, or <code>"sqrtninv"</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>delta</code></td>
<td>
<p>optional numeric vector (of the same length as the number of selection model parameters) to fix the corresponding \(\delta\) value(s). A specific \(\delta\) value can be fixed by setting the corresponding element of this argument to the desired value. A specific \(\delta\) value will be estimated if the corresponding element is set equal to <code>NA</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>steps</code></td>
<td>
<p>numeric vector of one or more values between 0 and 1 that can or must be specified for certain selection functions. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>logical to specify whether output should be generated on the progress of the model fitting (the default is <code>FALSE</code>). Can also be an integer. Values &gt; 1 generate more verbose output. See &lsquo;Note&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>digits</code></td>
<td>
<p>optional integer to specify the number of decimal places to which the printed results should be rounded. If unspecified, the default is to take the value from the object.</p>
</td></tr>
<tr valign="top"><td><code>control</code></td>
<td>
<p>optional list of control values for the estimation algorithm. If unspecified, default values are defined inside the function. See &lsquo;Note&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selection models are a general class of models that attempt to model the process by which the studies included in a meta-analysis may have been influenced by some form of publication bias. If a particular selection model is an adequate approximation for the underlying selection process, then the model provides estimates of the parameters of interest (e.g., the average true outcome and the amount of heterogeneity in the true outcomes) that are &lsquo;corrected&rsquo; for this selection process (i.e., they are estimates of the parameters in the population of studies before any selection has taken place). The present function fits a variety of such selection models. To do so, one should pass an object fitted with the <code><a href="rma.uni.html">rma.uni</a></code> function to the first argument. The model that will then be fitted is of the same form as the original model combined with the specific selection model chosen (see below for possible options). For example, if the original model was a random-effects model, then a random-effects selection model will be fitted. Similarly, if the original model included moderators, then they will also be included in the selection model. Model fitting is done via maximum likelihood (ML) estimation over the fixed- and random-effects parameters (e.g., \(\mu\) and \(\tau^2\) in a random-effects model) and the selection model parameters.
</p>
<p>Argument <code>type</code> determines the specific type of selection model that should be fitted. All selection models that can be fitted are based on the idea that selection may haven taken place based on the p-values of the studies. In particular, let \(y_i\) and \(v_i\) denote the observed outcome and the corresponding sampling variance of the \(i\textrm{th}\) study. Then \(z_i = y_i / \sqrt{v_i}\) is the (Wald-type) test statistic for testing the null hypothesis \(\mbox{H}_0{:}\; \theta_i = 0\) and \(p_i = 1 - \Phi(z_i)\) (if <code>alternative="greater"</code>), \(p_i = \Phi(z_i)\) (if <code>alternative="less"</code>), or \(p_i = 2(1 - \Phi(|z_i|))\) (if <code>alternative="two.sided"</code>) the corresponding (one- or two-sided) p-value, where \(\Phi()\) denotes the cumulative distribution function of a standard normal distribution. Finally, let \(w(p_i)\) denote some function that specifies the relative likelihood of selection given the p-value of a study.
</p>
<p>If \(w(p_i) > w(p_{i'})\) when \(p_i < p_{i'}\) (i.e., \(w(p_i)\) is larger for smaller p-values), then <code>alternative="greater"</code> implies selection in favor of increasingly significant positive outcomes, <code>alternative="less"</code> implies selection in favor of increasingly significant negative outcomes, and <code>alternative="two.sided"</code> implies selection in favor of increasingly significant outcomes regardless of their direction.
</p>


<h4>Beta Selection Model</h4>

<p>When <code>type="beta"</code>, the function can be used to fit the &lsquo;beta selection model&rsquo; by Citkowicz and Vevea (2017). For this model, the selection function is given by \[w(p_i) = p_i^{\delta_1 - 1} \times (1 - p_i)^{\delta_2 - 1}\] where \(\delta_1 > 0\) and \(\delta_2 > 0\). The null hypothesis \(\mbox{H}_0{:}\; \delta_1 = \delta_2 = 1\) represents the case where there is no selection (at least not depending on the p-values). The figure below illustrates with some examples how the relative likelihood of selection can depend on the p-value for various combinations of \(\delta_1\) and \(\delta_2\). Note that the model allows for a non-monotonic selection function.
</p>
<p><img src="../help/figures/selmodel-beta.png" width=600 />

</p>



<h4>Half-Normal, Negative-Exponential, Logistic, and Power Selection Models</h4>

<p>Preston et al. (2004) suggested the first three of the following selection functions:
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
      <b>name</b>          </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <b><code>type</code></b> </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <b>selection function</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
      half-normal          </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <code>"halfnorm"</code>  </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> \(w(p_i) = \exp(-\delta \times p_i^2)\) </td>
</tr>
<tr>
 <td style="text-align: left;">
      negative-exponential </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <code>"negexp"</code>    </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> \(w(p_i) = \exp(-\delta \times p_i)\) </td>
</tr>
<tr>
 <td style="text-align: left;">
      logistic             </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <code>"logistic"</code>  </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> \(w(p_i) = 2 \times \exp(-\delta \times p_i) / (1 + \exp(-\delta \times p_i))\) </td>
</tr>
<tr>
 <td style="text-align: left;">
      power                </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <code>"power"</code>     </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> \(w(p_i) = (1-p_i)^\delta\)
      </td>
</tr>

</table>

<p>The power selection model is added here as it has similar properties as the models suggested by Preston et al. (2004). For all models, assume \(\delta \ge 0\), so that all functions imply a monotonically decreasing relationship between the p-value and the selection probability. For all functions, \(\mbox{H}_0{:}\; \delta = 0\) implies no selection. The figure below shows the relative likelihood of selection as a function of the p-value for \(\delta = 0\) and for the various selection functions when \(\delta = 6\).
</p>
<p><img src="../help/figures/selmodel-preston.png" width=600 />

</p>
<p>Here, these functions are extended to allow for the possibility that \(w(p_i) = 1\) for p-values below a certain significance threshold denoted by \(\alpha\) (e.g., to model the case that the relative likelihood of selection is equally high for all significant studies but decreases monotonically for p-values above the significance threshold). To fit such a selection model, one should specify the \(\alpha\) value (with \(0 < \alpha < 1\)) via the <code>steps</code> argument. There must be at least one observed p-value below and above the chosen threshold to fit these models. The figure below shows some examples of the relative likelihood of selection when <code>steps=.05</code>.
</p>
<p><img src="../help/figures/selmodel-preston-step.png" width=600 />

</p>
<p>Preston et al. (2004) also suggested selection functions where the relatively likelihood of selection not only depends on the p-value, but also the precision (e.g., standard error) of the estimate (if two studies have similar p-values, it may be plausible to assume that the larger / more precise study has a higher probability of selection). These selection functions plus the corresponding power functions are given by:
</p>

<table summary="Rd table">
<tr>
 <td style="text-align: left;">
      <b>name</b>          </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <b><code>type</code></b> </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <b>selection function</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
      half-normal          </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <code>"halfnorm"</code>  </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> \(w(p_i) = \exp(-\delta \times \mathrm{prec}_i \times p_i^2)\) </td>
</tr>
<tr>
 <td style="text-align: left;">
      negative-exponential </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <code>"negexp"</code>    </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> \(w(p_i) = \exp(-\delta \times \mathrm{prec}_i \times p_i)\) </td>
</tr>
<tr>
 <td style="text-align: left;">
      logistic             </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <code>"logistic"</code>  </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> \(w(p_i) = 2 \times \exp(-\delta \times \mathrm{prec}_i \times p_i) / (1 + \exp(-\delta \times \mathrm{prec}_i \times p_i))\) </td>
</tr>
<tr>
 <td style="text-align: left;">
      power                </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> <code>"power"</code>     </td><td style="text-align: left;"> &emsp; </td><td style="text-align: left;"> \(w(p_i) = (1-p_i)^{\delta \times \mathrm{prec}_i}\)
      </td>
</tr>

</table>

<p>where \(\mathrm{prec}_i = \sqrt{v_i}\) (i.e., the standard error of the \(i\textrm{th}\) study) according to Preston et al. (2004). Here, this idea is generalized to allow the user to specify the specific measure of precision to use (via the <code>prec</code> argument). Possible options are:
</p>

<ul>
<li> <p><code>prec="sei"</code> for the standard errors,
</p>
</li>
<li> <p><code>prec="vi"</code> for the sampling variances,
</p>
</li>
<li> <p><code>prec="ninv"</code> for the inverse of the sample sizes,
</p>
</li>
<li> <p><code>prec="sqrtninv"</code> for the inverse square root of the sample sizes.
</p>
</li></ul>
<p> Using some function of the sample sizes as a measure of precision is only possible when information about the sample sizes is actually stored within the object passed to the <code>selmodel</code> function. See &lsquo;Note&rsquo;.
</p>
<p>Note that \(\mathrm{prec}_i\) is really a measure of imprecision (with higher values corresponding to lower precision). Also, regardless of the specific measure chosen, the values are actually rescaled with \(\mathrm{prec}_i = \mathrm{prec}_i / \max(\mathrm{prec}_i)\) inside of the function, such that \(\mathrm{prec}_i = 1\) for the least precise study and \(\mathrm{prec}_i < 1\) for the remaining studies (the rescaling does not actually change the fit of the model, it only helps to improve the stability of model fitting algorithm). The figure below shows some examples of the relative likelihood of selection using these selection functions for two different precision values.
</p>
<p><img src="../help/figures/selmodel-preston-prec.png" width=600 />

</p>
<p>One can also use the <code>steps</code> argument as described above in combination with these selection functions (studies with p-values below the chosen threshold then have \(w(p_i) = 1\) regardless of their exact p-value or precision).
</p>



<h4>Negative Exponential Power Selection Model</h4>

<p>As an extension of the half-normal and negative-exponential models, one can also choose <code>type="negexppow"</code> for a &lsquo;negative exponential power selection model&rsquo;. The selection function is then given by \[w(p_i) = \exp(-\delta_1 \times p_i^{1/\delta_2})\] where \(\delta_1 \ge 0\) and \(\delta_2 \ge 0\) (see Begg &amp; Mazumdar, 1994, although here a different parameterization is used, such that increasing \(\delta_2\) leads to more severe selection). The figure below shows some examples of this selection function when holding \(\delta_1\) constant while increasing \(\delta_2\).
</p>
<p><img src="../help/figures/selmodel-negexppow.png" width=600 />

</p>
<p>This model affords greater flexibility in the shape of the selection function, but requires the estimation of the additional power parameter (the half-normal and negative-exponential models are therefore special cases when fixing \(\delta_2\) to 0.5 or 1, respectively). \(\mbox{H}_0{:}\; \delta_1 = 0\) again implies no selection, but so does \(\mbox{H}_0{:}\; \delta_2 = 0\).
</p>
<p>One can again use the <code>steps</code> argument to specify a single significance threshold, \(\alpha\), so that \(w(p_i) = 1\) for p-values below this threshold and otherwise \(w(p_i)\) follows the selection function as given above. One can also use the <code>prec</code> argument to specify a measure of precision in combination with this model, which leads to the selection function \[w(p_i) = \exp(-\delta_1 \times \mathrm{prec}_i \times p_i^{1/\delta_2})\] and hence is the logical extension of the negative exponential power selection model that also incorporates some measure of precision into the selection process.
</p>



<h4>Step Function Selection Models</h4>

<p>When <code>type="stepfun"</code>, the function can be used to fit &lsquo;step function models&rsquo; as described by Iyengar and Greenhouse (1988), Hedges (1992), Vevea and Hedges (1995), and Vevea and Woods (2005). For these models, one must specify one or multiple values via the <code>steps</code> argument, which define intervals in which the relative likelihood of selection is constant. Let \[\alpha_1 < \alpha_2 < \ldots < \alpha_c\] denote these cutpoints sorted in increasing order, with the constraint that \(\alpha_c = 1\) (if the highest value specified via <code>steps</code> is not 1, the function will automatically add this cutpoint), and define \(\alpha_0 = 0\). The selection function is then given by \(w(p_i) = \delta_j\) if \(\alpha_{j-1} < p_i \le \alpha_j\). To make the model identifiable, we set \(\delta_1 = 1\). The \(\delta_j\) values therefore denote the likelihood of selection in the various intervals relative to the interval for p-values between 0 and \(\alpha_1\). Hence, the null hypothesis \(\mbox{H}_0{:}\; \delta_j = 1\) for \(j = 1, \ldots, c\) implies no selection.
</p>
<p>For example, if <code>steps=c(.05, .10, .50, 1)</code>, then \(\delta_2\) is the likelihood of selection for p-values between .05 and .10, \(\delta_3\) is the likelihood of selection for p-values between .10 and .50, and \(\delta_4\) is the likelihood of selection for p-values between .50 and 1 relative to the likelihood of selection for p-values between 0 and .05. The figure below shows the corresponding selection function for some arbitrarily chosen \(\delta_j\) values.
</p>
<p><img src="../help/figures/selmodel-stepfun.png" width=600 />

</p>
<p>There must be at least one observed p-value within each interval to fit this model. If this is not the case, an error will be issued (setting <code>verbose=TRUE</code> provides information about the number of p-values falling into each interval).
</p>
<p>When specifying a single cutpoint in the context of a random-effects model, this model is sometimes called the &lsquo;three-parameter selection model&rsquo; (3PSM), corresponding to the parameters \(\mu\), \(\tau^2\), and \(\delta_2\) (e.g., Carter et al., 2019; McShane et al., 2016; Pustejovsky &amp; Rodgers, 2019). The same idea but in the context of an equal-effects model was also described by Iyengar and Greenhouse (1988).
</p>
<p>Note that when <code>alternative="greater"</code> or <code>alternative="less"</code> (i.e., when we assume that the relative likelihood of selection is not only related to the p-values of the studies, but also the directionality of the outcomes), then it would usually make sense to divide conventional levels of significance (e.g., .05) by 2 before passing these values to the <code>steps</code> argument. For example, if we think that studies were selected for positive outcomes that are significant at two-tailed \(\alpha = .05\), then we should use <code>alternative="greater"</code> in combination with <code>steps=c(.025, 1)</code>.
</p>
<p>One of the challenges when fitting this model with many cutpoints is the large number of parameters that need to be estimated (which is especially problematic when the number of studies is small). An alternative approach suggested by Vevea and Woods (2005) is to fix the \(\delta_j\) values to some a priori chosen values instead of estimating them. One can then conduct a sensitivity analysis by examining the results (e.g., the estimates of \(\mu\) and \(\tau^2\) in a random-effects model) for a variety of different sets of \(\delta_j\) values (reflecting more or less severe forms of selection). This can be done by specifying the \(\delta_j\) values via the <code>delta</code> argument. Table 1 in Vevea and Woods (2005) provides some illustrative examples of moderate and severe selection functions for one- and two-tailed selection. The code below creates a data frame that contains these functions.
</p>
<pre>tab &lt;- data.frame(
  steps = c(0.005, 0.01, 0.05, 0.10, 0.25, 0.35, 0.50, 0.65, 0.75, 0.90, 0.95, 0.99, 0.995, 1),
  delta.mod.1 = c(1, 0.99, 0.95, 0.80, 0.75, 0.65, 0.60, 0.55, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50),
  delta.sev.1 = c(1, 0.99, 0.90, 0.75, 0.60, 0.50, 0.40, 0.35, 0.30, 0.25, 0.10, 0.10, 0.10, 0.10),
  delta.mod.2 = c(1, 0.99, 0.95, 0.90, 0.80, 0.75, 0.60, 0.60, 0.75, 0.80, 0.90, 0.95, 0.99, 1.00),
  delta.sev.2 = c(1, 0.99, 0.90, 0.75, 0.60, 0.50, 0.25, 0.25, 0.50, 0.60, 0.75, 0.90, 0.99, 1.00))</pre>
<p>The figure below shows the corresponding selection functions.
</p>
<p><img src="../help/figures/selmodel-stepfun-fixed.png" width=600 />

</p>
<p>These four functions are &ldquo;merely examples and should not be regarded as canonical&rdquo; (Vevea &amp; Woods, 2005).
</p>



<h3>Value</h3>

<p>An object of class <code>c("rma.uni","rma")</code>. The object is a list containing the same components as a regular <code>c("rma.uni","rma")</code> object, but the parameter estimates are based on the selection model. Most importantly, the following elements are modified based on the selection model:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>beta</code></td>
<td>
<p>estimated coefficients of the model.</p>
</td></tr>
<tr valign="top"><td><code>se</code></td>
<td>
<p>standard errors of the coefficients.</p>
</td></tr>
<tr valign="top"><td><code>zval</code></td>
<td>
<p>test statistics of the coefficients.</p>
</td></tr>
<tr valign="top"><td><code>pval</code></td>
<td>
<p>corresponding p-values.</p>
</td></tr>
<tr valign="top"><td><code>ci.lb</code></td>
<td>
<p>lower bound of the confidence intervals for the coefficients.</p>
</td></tr>
<tr valign="top"><td><code>ci.ub</code></td>
<td>
<p>upper bound of the confidence intervals for the coefficients.</p>
</td></tr>
<tr valign="top"><td><code>vb</code></td>
<td>
<p>variance-covariance matrix of the estimated coefficients.</p>
</td></tr>
<tr valign="top"><td><code>tau2</code></td>
<td>
<p>estimated amount of (residual) heterogeneity. Always <code>0</code> when <code>method="EE"</code>.</p>
</td></tr>
<tr valign="top"><td><code>se.tau2</code></td>
<td>
<p>standard error of the estimated amount of (residual) heterogeneity.</p>
</td></tr>
</table>
<p>In addition, the object contains the following additional elements:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>delta</code></td>
<td>
<p>estimated selection model parameter(s).</p>
</td></tr>
<tr valign="top"><td><code>se.delta</code></td>
<td>
<p>corresponding standard error(s).</p>
</td></tr>
<tr valign="top"><td><code>zval.delta</code></td>
<td>
<p>corresponding test statistic(s).</p>
</td></tr>
<tr valign="top"><td><code>pval.delta</code></td>
<td>
<p>corresponding p-value(s).</p>
</td></tr>
<tr valign="top"><td><code>ci.lb.delta</code></td>
<td>
<p>lower bound of the confidence intervals for the parameter(s).</p>
</td></tr>
<tr valign="top"><td><code>ci.ub.delta</code></td>
<td>
<p>upper bound of the confidence intervals for the parameter(s).</p>
</td></tr>
<tr valign="top"><td><code>LRT</code></td>
<td>
<p>test statistic of the likelihood ratio test for the selection model parameter(s).</p>
</td></tr>
<tr valign="top"><td><code>LRTdf</code></td>
<td>
<p>degrees of freedom for the likelihood ratio test.</p>
</td></tr>
<tr valign="top"><td><code>LRTp</code></td>
<td>
<p>p-value for the likelihood ratio test.</p>
</td></tr>
<tr valign="top"><td><code>LRT.tau2</code></td>
<td>
<p>test statistic of the likelihood ratio test for testing \(\mbox{H}_0{:}\; \tau^2 = 0\) (<code>NA</code> when fitting an equal-effects model).</p>
</td></tr>
<tr valign="top"><td><code>LRTp.tau2</code></td>
<td>
<p>p-value for the likelihood ratio test.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>some additional elements/values.</p>
</td></tr>
</table>


<h3>Methods</h3>

<p>The results of the fitted model are formatted and printed with the <code><a href="print.rma.html">print</a></code> function. The estimated selection function can be drawn with <code><a href="plot.rma.uni.selmodel.html">plot</a></code>.
</p>
<p>The <code><a href="profile.rma.html">profile</a></code> function can be used to obtain a plot of the log-likelihood as a function of \(\tau^2\) and/or the selection model parameter(s) of the model. Corresponding confidence intervals can be obtained with the <code><a href="confint.rma.html">confint</a></code> function.
</p>


<h3>Note</h3>

<p>Model fitting is done via numerical optimization over the model parameters. By default, <code><a href="../../stats/html/optim.html">optim</a></code> with method <code>"BFGS"</code> is used for the optimization. One can also chose a different optimizer from <code><a href="../../stats/html/optim.html">optim</a></code> via the <code>control</code> argument (e.g., <code>control=list(optimizer="Nelder-Mead")</code>). Besides one of the methods from <code><a href="../../stats/html/optim.html">optim</a></code>, one can also choose the quasi-Newton algorithm in <code><a href="../../stats/html/nlminb.html">nlminb</a></code>, one of the optimizers from the <code>minqa</code> package (i.e., <code><a href="../../minqa/html/uobyqa.html">uobyqa</a></code>, <code><a href="../../minqa/html/newuoa.html">newuoa</a></code>, or <code><a href="../../minqa/html/bobyqa.html">bobyqa</a></code>), one of the (derivative-free) algorithms from the <code><a href="../../nloptr/html/nloptr.html">nloptr</a></code> package, the Newton-type algorithm implemented in <code><a href="../../stats/html/nlm.html">nlm</a></code>, the various algorithms implemented in the <code>dfoptim</code> package (<code><a href="../../dfoptim/html/hjk.html">hjk</a></code> for the Hooke-Jeeves, <code><a href="../../dfoptim/html/nmk.html">nmk</a></code> for the Nelder-Mead, and <code><a href="../../dfoptim/html/mads.html">mads</a></code> for the Mesh Adaptive Direct Searches (MADS) algorithm), the quasi-Newton type optimizers <code><a href="../../ucminf/html/ucminf.html">ucminf</a></code> and <code><a href="../../lbfgsb3c/html/lbfgsb3c.html">lbfgsb3c</a></code> and the subspace-searching simplex algorithm <code><a href="../../subplex/html/subplex.html">subplex</a></code> from the packages of the same name, the Barzilai-Borwein gradient decent method implemented in <code><a href="../../BB/html/BBoptim.html">BBoptim</a></code>, or the parallelized version of the L-BFGS-B algorithm implemented in <code><a href="../../optimParallel/html/optimParallel.html">optimParallel</a></code> from the package of the same name.
</p>
<p>The optimizer name must be given as a character string (i.e., in quotes). Additional control parameters can be specified via the <code>control</code> argument (e.g., <code>control=list(maxit=1000, reltol=1e-8)</code>). For <code><a href="../../nloptr/html/nloptr.html">nloptr</a></code>, the default is to use the BOBYQA implementation from that package with a relative convergence criterion of <code>1e-8</code> on the function value (i.e., log-likelihood), but this can be changed via the <code>algorithm</code> and <code>ftop_rel</code> arguments (e.g., <code>control=list(optimizer="nloptr", algorithm="NLOPT_LN_SBPLX", ftol_rel=1e-6)</code>). For <code><a href="../../optimParallel/html/optimParallel.html">optimParallel</a></code>, the control argument <code>ncpus</code> can be used to specify the number of cores to use for the parallelization (e.g., <code>control=list(optimizer="optimParallel", ncpus=2)</code>). With <code>parallel::detectCores()</code>, one can check on the number of available cores on the local machine.
</p>
<p>All selection models (except for <code>type="stepfun"</code>) require repeated evaluations of an integral, which is done via adaptive quadrature as implemented in the <code><a href="../../stats/html/integrate.html">integrate</a></code> function. One can adjust the arguments of the <code>integrate</code> function via control element <code>intCtrl</code>, which is a list of named arguments (e.g., <code>control = list(intCtrl = list(rel.tol=1e-4, subdivisions=100))</code>).
</p>
<p>The starting values for the fixed effects, the \(\tau^2\) value (only relevant in random/mixed-effects models), and the \(\delta\) parameter(s) are chosen automatically by the function, but one can also set the starting values manually via the <code>control</code> argument by specifying a vector of the appropriate length for <code>beta.init</code>, a single value for <code>tau2.init</code>, and a vector of the appropriate length for <code>delta.init</code>.
</p>
<p>By default, the \(\delta\) parameter(s) are constrained to a certain range, which improves the stability of the optimization algorithm. For all models, the maximum is set to <code>100</code> and the minimum to <code>0</code> (except for <code>type="beta"</code>, where the minimum for both parameters is <code>1e-05</code>). These defaults can be changed via the <code>control</code> argument by specifying a vector of the appropriate length for <code>delta.min</code> and/or <code>delta.max</code>.
</p>
<p>A difficulty with fitting the beta selection model (i.e., <code>type="beta"</code>) is the behavior of \(w(p_i)\) when \(p_i = 0\) or \(p_i = 1\). When \(\delta_1 < 1\) or \(\delta_2 < 1\), then this leads to selection weights equal to infinity, which causes problems when computing the likelihood function. Following Citkowicz and Vevea (2017), this problem can be avoided by censoring p-values too close to 0 or 1. The specific censoring point can be set via the <code>pval.min</code> element of the <code>control</code> argument. The default for this selection model is <code>control=list(pval.min=1e-5)</code>. A similar issues arises for the power selection model (i.e., <code>type="power"</code>) when \(p_i = 1\). Again, <code>pval.min=1e-5</code> is used to circumvent this issue. For all other selection models, the default is <code>pval.min=0</code>.
</p>
<p>The variance-covariance matrix corresponding to the estimates of the fixed effects, the \(\tau^2\) value (only relevant in random/mixed-effects models), and the \(\delta\) parameter(s) is obtained by inverting the Hessian, which is numerically approximated using the <code><a href="../../numDeriv/html/hessian.html">hessian</a></code> function from the <code>numDeriv</code> package. This may fail, leading to <code>NA</code> values for the standard errors and hence test statistics, p-values, and confidence interval bounds. One can set control argument <code>hessianCtrl</code> to a list of named arguments to be passed on to the <code>method.args</code> argument of the <code><a href="../../numDeriv/html/hessian.html">hessian</a></code> function (the default is <code>control=list(hessianCtrl=list(r=6))</code>).
</p>
<p>Information on the progress of the optimization algorithm can be obtained by setting <code>verbose=TRUE</code> (this won't work when using parallelization). This option is useful to determine how the model fitting is progressing. One can also set <code>verbose</code> to an integer (<code>verbose=2</code> yields even more information and <code>verbose=3</code> also show the progress visually by drawing the selection function as the optimization proceeds).
</p>
<p>For selection functions where the <code>prec</code> argument is relevant, using (a function of) the sample sizes as the measure of precision (i.e., <code>prec="ninv"</code> or <code>prec="sqrtninv"</code>) is only possible when information about the sample sizes is actually stored within the object passed to the <code>selmodel</code> function. That should automatically be the case when the observed effect sizes or outcomes were computed with the <code><a href="escalc.html">escalc</a></code> function or when the observed effect sizes or outcomes were computed within the model fitting function. On the other hand, this will not be the case when <code><a href="rma.uni.html">rma.uni</a></code> was used together with the <code>yi</code> and <code>vi</code> arguments and the <code>yi</code> and <code>vi</code> values were <em>not</em> computed with <code><a href="escalc.html">escalc</a></code>. In that case, it is still possible to pass information about the sample sizes to the <code><a href="rma.uni.html">rma.uni</a></code> function (e.g., use <code>rma.uni(yi, vi, ni=ni, data=dat)</code>, where data frame <code>dat</code> includes a variable called <code>ni</code> with the sample sizes).
</p>
<p>Finally, the automatic rescaling of the chosen precision measure can be switched off by setting <code>scaleprec=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Viechtbauer <a href="mailto:wvb@metafor-project.org">wvb@metafor-project.org</a> <a href="https://www.metafor-project.org">https://www.metafor-project.org</a>
</p>


<h3>References</h3>

<p>Begg, C. B., &amp; Mazumdar, M. (1994). Operating characteristics of a rank correlation test for publication bias. <em>Biometrics</em>, <b>50</b>(4), 1088&ndash;1101. <code style="white-space: pre;">https://doi.org/10.2307/2533446</code>
</p>
<p>Carter, E. C., Schönbrodt, F. D., Gervais, W. M., &amp; Hilgard, J. (2019). Correcting for bias in psychology: A comparison of meta-analytic methods. <em>Advances in Methods and Practices in Psychological Science</em>, <b>2</b>(2), 115&ndash;144. <code style="white-space: pre;">https://doi.org/10.1177/2515245919847196</code>
</p>
<p>Citkowicz, M., &amp; Vevea, J. L. (2017). A parsimonious weight function for modeling publication bias. <em>Psychological Methods</em>, <b>22</b>(1), 28&ndash;41. <code style="white-space: pre;">https://doi.org/10.1037/met0000119</code>
</p>
<p>Hedges, L. V. (1992). Modeling publication selection effects in meta-analysis. <em>Statistical Science</em>, <b>7</b>(2), 246&ndash;255. <code style="white-space: pre;">https://doi.org/10.1214/ss/1177011364</code>
</p>
<p>Iyengar, S., &amp; Greenhouse, J. B. (1988). Selection models and the file drawer problem. <em>Statistical Science</em>, <b>3</b>(1), 109&ndash;117. <code style="white-space: pre;">https://doi.org/10.1214/ss/1177013012</code>
</p>
<p>McShane, B. B., Bockenholt, U., &amp; Hansen, K. T. (2016). Adjusting for publication bias in meta-analysis: An evaluation of selection methods and some cautionary notes. <em>Perspectives on Psychological Science</em>, <b>11</b>(5), 730&ndash;749. <code style="white-space: pre;">https://doi.org/10.1177/1745691616662243</code>
</p>
<p>Preston, C., Ashby, D., &amp; Smyth, R. (2004). Adjusting for publication bias: Modelling the selection process. <em>Journal of Evaluation in Clinical Practice</em>, <b>10</b>(2), 313&ndash;322. <code style="white-space: pre;">https://doi.org/10.1111/j.1365-2753.2003.00457.x</code>
</p>
<p>Pustejovsky, J. E., &amp; Rodgers, M. A. (2019). Testing for funnel plot asymmetry of standardized mean differences. <em>Research Synthesis Methods</em>, <b>10</b>(1), 57&ndash;71. <code style="white-space: pre;">https://doi.org/10.1002/jrsm.1332</code>
</p>
<p>Vevea, J. L., &amp; Hedges, L. V. (1995). A general linear model for estimating effect size in the presence of publication bias. <em>Psychometrika</em>, <b>60</b>(3), 419&ndash;435. <code style="white-space: pre;">https://doi.org/10.1007/BF02294384</code>
</p>
<p>Vevea, J. L., &amp; Woods, C. M. (2005). Publication bias in research synthesis: Sensitivity analysis using a priori weight functions. <em>Psychological Methods</em>, <b>10</b>(4), 428&ndash;443. <code style="white-space: pre;">https://doi.org/10.1037/1082-989X.10.4.428</code>
</p>


<h3>See Also</h3>

<p><code><a href="rma.uni.html">rma.uni</a></code> for the function to fit models which can be extended with selection models.
</p>


<h3>Examples</h3>

<pre>
############################################################################

### example from Citkowicz and Vevea (2017) for beta selection model

# copy data into 'dat' and examine data
dat &lt;- dat.baskerville2012
dat

# fit random-effects model
res &lt;- rma(smd, se^2, data=dat, method="ML", digits=3)
res

# funnel plot
funnel(res, ylim=c(0,0.6), xlab="Standardized Mean Difference")

# fit beta selection model
## Not run: 
sel &lt;- selmodel(res, type="beta")
sel

# plot selection function
plot(sel, ylim=c(0,40))

## End(Not run)

# fit mixed-effects meta-regression model with 'blind' dummy variable as moderator
res &lt;- rma(smd, se^2, data=dat, mods = ~ blind, method="ML", digits=3)
res

# predicted average effect for studies that do not and that do use blinding
predict(res, newmods=c(0,1))

# fit beta selection model
## Not run: 
sel &lt;- selmodel(res, type="beta")
sel
predict(sel, newmods=c(0,1))

## End(Not run)

############################################################################

### example from Preston et al. (2004)

# copy data into 'dat' and examine data
dat &lt;- dat.hahn2001
dat

### meta-analysis of (log) odds rations using the Mantel-Haenszel method
res &lt;- rma.mh(measure="OR", ai=ai, n1i=n1i, ci=ci, n2i=n2i, data=dat, digits=2, slab=study)
res

# calculate log odds ratios and corresponding sampling variances
dat &lt;- escalc(measure="OR", ai=ai, n1i=n1i, ci=ci, n2i=n2i, data=dat, drop00=TRUE)
dat

# fit equal-effects model
res &lt;- rma(yi, vi, data=dat, method="EE")

# predicted odds ratio (with 95% CI)
predict(res, transf=exp, digits=2)

# funnel plot
funnel(res, atransf=exp, at=log(c(0.01,0.1,1,10,100)), ylim=c(0,2))

# fit half-normal, negative-exponential, logistic, and power selection models
## Not run: 
sel1 &lt;- selmodel(res, type="halfnorm", alternative="less")
sel2 &lt;- selmodel(res, type="negexp",   alternative="less")
sel3 &lt;- selmodel(res, type="logistic", alternative="less")
sel4 &lt;- selmodel(res, type="power",    alternative="less")

# plot selection functions
plot(sel1)
plot(sel2, add=TRUE, col="blue")
plot(sel3, add=TRUE, col="red")
plot(sel4, add=TRUE, col="green")

# add legend
legend("topright", inset=.02, lty="solid", lwd=2, col=c("black","blue","red","green"),
       legend=c("Half-normal", "Negative-exponential", "Logistic", "Power"))

# show estimates of delta (and corresponding SEs)
tab &lt;- data.frame(delta = c(sel1$delta, sel2$delta, sel3$delta, sel4$delta),
                  se    = c(sel1$se.delta, sel2$se.delta, sel3$se.delta, sel4$se.delta))
rownames(tab) &lt;- c("Half-normal", "Negative-exponential", "Logistic", "Power")
round(tab, 2)

# predicted odds ratios (with 95% CI)
predict(res,  transf=exp, digits=2)
predict(sel1, transf=exp, digits=2)
predict(sel2, transf=exp, digits=2)
predict(sel3, transf=exp, digits=2)
predict(sel4, transf=exp, digits=2)

## End(Not run)

# fit selection models including standard error as precision measure (note: using
# scaleprec=FALSE here since Preston et al. (2004) did not use the rescaling)
## Not run: 
sel1 &lt;- selmodel(res, type="halfnorm", prec="sei", alternative="less", scaleprec=FALSE)
sel2 &lt;- selmodel(res, type="negexp",   prec="sei", alternative="less", scaleprec=FALSE)
sel3 &lt;- selmodel(res, type="logistic", prec="sei", alternative="less", scaleprec=FALSE)
sel4 &lt;- selmodel(res, type="power",    prec="sei", alternative="less", scaleprec=FALSE)

# show estimates of delta (and corresponding SEs)
tab &lt;- data.frame(delta = c(sel1$delta, sel2$delta, sel3$delta, sel4$delta),
                  se    = c(sel1$se.delta, sel2$se.delta, sel3$se.delta, sel4$se.delta))
rownames(tab) &lt;- c("Half-normal", "Negative-exponential", "Logistic", "Power")
round(tab, 2)

# predicted odds ratio (with 95% CI)
predict(res,  transf=exp, digits=2)
predict(sel1, transf=exp, digits=2)
predict(sel2, transf=exp, digits=2)
predict(sel3, transf=exp, digits=2)
predict(sel4, transf=exp, digits=2)

## End(Not run)

############################################################################

### meta-analysis on the effect of environmental tobacco smoke on lung cancer risk

# copy data into 'dat' and examine data
dat &lt;- dat.hackshaw1998
dat

# fit random-effects model
res &lt;- rma(yi, vi, data=dat, method="ML")
res

# funnel plot
funnel(res, atransf=exp, at=log(c(0.25,0.5,1,2,4,8)), ylim=c(0,0.8))

# step function selection model
## Not run: 
sel &lt;- selmodel(res, type="stepfun", alternative="greater", steps=c(.025,.10,.50,1))
sel

# plot selection function
plot(sel)

## End(Not run)

############################################################################

### validity of student ratings example from Vevea &amp; Woods (2005)

# copy data into 'dat' and examine data
dat &lt;- dat.cohen1981
dat[c(1,4,5)]

# calculate r-to-z transformed correlations and corresponding sampling variances
dat &lt;- escalc(measure="ZCOR", ri=ri, ni=ni, data=dat[c(1,4,5)])
dat

# fit random-effects model
res &lt;- rma(yi, vi, data=dat, method="ML", digits=3)
res

# predicted average correlation (with 95% CI)
predict(res, transf=transf.ztor)

# funnel plot
funnel(res, ylim=c(0,0.4))

# selection functions from Vevea &amp; Woods (2005)
tab &lt;- data.frame(
   steps = c(0.005, 0.01, 0.05, 0.10, 0.25, 0.35, 0.50, 0.65, 0.75, 0.90, 0.95, 0.99, 0.995, 1),
   delta.mod.1 = c(1, 0.99, 0.95, 0.80, 0.75, 0.65, 0.60, 0.55, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50),
   delta.sev.1 = c(1, 0.99, 0.90, 0.75, 0.60, 0.50, 0.40, 0.35, 0.30, 0.25, 0.10, 0.10, 0.10, 0.10),
   delta.mod.2 = c(1, 0.99, 0.95, 0.90, 0.80, 0.75, 0.60, 0.60, 0.75, 0.80, 0.90, 0.95, 0.99, 1.00),
   delta.sev.2 = c(1, 0.99, 0.90, 0.75, 0.60, 0.50, 0.25, 0.25, 0.50, 0.60, 0.75, 0.90, 0.99, 1.00))

# apply step function model with a priori chosen selection weights
## Not run: 
sel &lt;- lapply(tab[-1], function(delta) selmodel(res, type="stepfun", steps=tab$steps, delta=delta))

# estimates (transformed correlation) and tau^2 values
sav &lt;- data.frame(estimate = round(c(res$beta, sapply(sel, function(x) x$beta)), 2),
                  varcomp  = round(c(res$tau2, sapply(sel, function(x) x$tau2)), 3))
sav

## End(Not run)

############################################################################
</pre>

<hr /><div style="text-align: center;">[Package <em>metafor</em> version 3.4-0 <a href="00Index.html">Index</a>]</div>
</body></html>
