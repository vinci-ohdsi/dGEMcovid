<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Construct or Approximate the Variance-Covariance Matrix of...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for vcalc {metafor}"><tr><td>vcalc {metafor}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Construct or Approximate the Variance-Covariance Matrix of Dependent Effect Sizes or Outcomes</h2>

<h3>Description</h3>

<p>The function can be used to construct or approximate the variance-covariance matrix of dependent effect sizes or outcomes, or more precisely, of their sampling errors (i.e., the <code>V</code> matrix in <code><a href="rma.mv.html">rma.mv</a></code>). <script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
</p>


<h3>Usage</h3>

<pre>
vcalc(vi, cluster, subgroup, obs, type, time1, time2, grp1, grp2, w1, w2,
      data, rho, phi, rvars, checkpd=TRUE, nearpd=FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>vi</code></td>
<td>
<p>numeric vector to specify the sampling variances of the observed effect sizes or outcomes.</p>
</td></tr>
<tr valign="top"><td><code>cluster</code></td>
<td>
<p>vector to specify the clustering variable (e.g., study).</p>
</td></tr>
<tr valign="top"><td><code>subgroup</code></td>
<td>
<p>optional vector to specify different (independent) subgroups within clusters.</p>
</td></tr>
<tr valign="top"><td><code>obs</code></td>
<td>
<p>optional vector to distinguish different observed effect sizes or outcomes corresponding to the same construct or response/dependent variable.</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p>optional vector to distinguish different types of constructs or response/dependent variables underlying the observed effect sizes or outcomes.</p>
</td></tr>
<tr valign="top"><td><code>time1</code></td>
<td>
<p>optional numeric vector to specify the time points when the observed effect sizes or outcomes were obtained (in the first condition if the observed effect sizes or outcomes represent contrasts between two conditions).</p>
</td></tr>
<tr valign="top"><td><code>time2</code></td>
<td>
<p>optional numeric vector to specify the time points when the observed effect sizes or outcomes were obtained in the second condition (only relevant when the observed effect sizes or outcomes represent contrasts between two conditions).</p>
</td></tr>
<tr valign="top"><td><code>grp1</code></td>
<td>
<p>optional vector to specify the group of the first condition when the observed effect sizes or outcomes represent contrasts between two conditions.</p>
</td></tr>
<tr valign="top"><td><code>grp2</code></td>
<td>
<p>optional vector to specify the group of the second condition when the observed effect sizes or outcomes represent contrasts between two conditions.</p>
</td></tr>
<tr valign="top"><td><code>w1</code></td>
<td>
<p>optional numeric vector to specify the size of the group (or more generally, the inverse-sampling variance weight) of the first condition when the observed effect sizes or outcomes represent contrasts between two conditions.</p>
</td></tr>
<tr valign="top"><td><code>w2</code></td>
<td>
<p>optional numeric vector to specify the size of the group (or more generally, the inverse-sampling variance weight) of the second condition when the observed effect sizes or outcomes represent contrasts between two conditions.</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
<p>optional data frame containing the variables given to the arguments above.</p>
</td></tr>
<tr valign="top"><td><code>rho</code></td>
<td>
<p>argument to specify the correlation(s) of observed effect sizes or outcomes measured concurrently. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>phi</code></td>
<td>
<p>argument to specify the autocorrelation of observed effect sizes or outcomes measured at different time points. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>rvars</code></td>
<td>
<p>optional argument for specifying the variables that correspond to the correlation matrices of the studies (if this is specified, all arguments above except for <code>cluster</code> and <code>subgroup</code> are ignored). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>checkpd</code></td>
<td>
<p>logical to specify whether to check that the variance-covariance matrices within clusters are positive definite (the default is <code>TRUE</code>). See &lsquo;Note&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>nearpd</code></td>
<td>
<p>logical to specify whether the <code><a href="../../Matrix/html/nearPD.html">nearPD</a></code> function from the <a href="https://cran.r-project.org/package=Matrix">Matrix</a> package should be used on variance-covariance matrices that are not positive definite. See &lsquo;Note&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard meta-analytic models (such as those that can be fitted with the <code><a href="rma.uni.html">rma.uni</a></code> function) assume that the observed effect sizes or outcomes (or more precisely, their sampling errors) are independent. This assumption is typically violated whenever multiple observed effect sizes or outcomes are computed based on the same sample of subjects (or whatever the study units are) or if there is at least partial overlap of subjects that contribute information to the computation of multiple effect sizes or outcomes.
</p>
<p>The present function can be used to construct or approximate the variance-covariance matrix of the sampling errors of dependent effect sizes or outcomes for a wide variety of circumstances (this variance-covariance matrix is the so-called <code>V</code> matrix that may be needed as input for multilevel/multivariate meta-analytic models as can be fitted with the <code><a href="rma.mv.html">rma.mv</a></code> function; see also <a href="misc-recs.html">here</a> for some recommendations on a general workflow for meta-analyses involving complex dependency structures).
</p>
<p>Argument <code>cluster</code> is used to specify the clustering variable. Rows with the same value of this variable are allowed to be dependent, while rows with different values are assumed to be independent. Typically, <code>cluster</code> will be a study identifier.
</p>
<p>Within the same cluster, there may be different subgroups with no overlap of subjects across subgroups. Argument <code>subgroup</code> can be used to distinguish such subgroups. Rows with the same value of this variable within a cluster are allowed to be dependent, while rows with different values are assumed to be independent even if they come from the same cluster. Therefore, from hereon, &lsquo;cluster&rsquo; really refers to the combination of <code>cluster</code> and <code>subgroup</code>.
</p>
<p>Multiple effect sizes or outcomes belonging to the same cluster may be dependent due to a variety of reasons:
</p>

<ol>
<li><p> The same construct of interest (e.g., severity of depression) may have been measured using different scales or instruments within a study (e.g., using the Beck Depression Inventory (BDI) and the Hamilton Depression Rating Scale (HDRS)) based on which multiple effect sizes can be computed for the same group of subjects (e.g., contrasting a treatment versus a control group with respect to each scale). In this case, we have multiple effect sizes that are different &lsquo;observations&rsquo; of the effect with respect to the same type of construct.
</p>
<p>Argument <code>obs</code> is then used to distinguish different effect sizes corresponding to the same construct. If <code>obs</code> is specified, then argument <code>rho</code> must also be specified to indicate the degree of correlation among the sampling errors of the different effect sizes. Since this correlation is typically not known, the correlation among the various scales (or a rough &lsquo;guestimate&rsquo; thereof) can be used as a proxy (i.e., the (typical) correlation between BDI and HDRS measurements).
</p>
<p>One can also specify an entire correlation matrix via <code>rho</code> to indicate, for each possible pair of <code>obs</code> values, the corresponding correlation. The row/column names of the matrix must then correspond to the unique values of the <code>obs</code> variable.
</p>
</li>
<li><p> Multiple types of constructs (or more generally, types of response/dependent variables) may have been measured in the same group of subjects (e.g., severity of depression as measured with the Beck Depression Inventory (BDI) and severity of anxiety as measured with the State-Trait Anxiety Inventory (STAI)). If this is of interest for a meta-analysis, effect sizes can then be computed with respect to each &lsquo;type&rsquo; of construct.
</p>
<p>Argument <code>type</code> is then used to distinguish effect sizes corresponding to these different types of constructs. If <code>type</code> is specified, then argument <code>rho</code> must also be specified to indicate the degree of correlation among the sampling errors of effect sizes belonging to these different types. As above, the correlation among the various scales is typically used here as a proxy (i.e., the (typical) correlation between BDI and STAI measurements).
</p>
<p>One can also specify an entire correlation matrix via <code>rho</code> to indicate, for each possible pair of <code>type</code> values, the corresponding correlation. The row/column names of the matrix must then correspond to the unique values of the <code>type</code> variable.
</p>
</li>
<li><p> If there are multiple types of constructs, multiple scales or instruments may also have been used (in at least some of the studies) to measure the same construct and hence there may again be multiple effect sizes that are &lsquo;observations&rsquo; of the same type of construct. Arguments <code>type</code> and <code>obs</code> should then be used together to indicate the various construct types and observations thereof. In this case, argument <code>rho</code> must be a vector of two values, the first to specify the within-construct correlation and the second to specify the between-construct correlation.
</p>
<p>One can also specify a list with two elements for <code>rho</code>, the first element being either a scalar or an entire correlation matrix for the within-construct correlation(s) and the second element being a scalar or an entire correlation matrix for the between-construct correlation(s). As above, any matrices specified must have row/column names corresponding to the unique values of the <code>obs</code> and/or <code>type</code> variables.
</p>
</li>
<li><p> The same construct and scale may have been assessed/used multiple times, allowing the computation of multiple effect sizes for the same group of subjects at different time points (e.g., right after the end of a treatment, at a short-term follow-up, and at a long-term follow-up). Argument <code>time1</code> is then used to specify the time points when the observed effect sizes were obtained. Argument <code>phi</code> must then also be specified to indicate the autocorrelation among the sampling errors of two effect sizes that differ by one unit on the <code>time1</code> variable. As above, the autocorrelation of the measurements themselves can be used here as a proxy.
</p>
<p>If multiple constructs and/or multiple scales have also been assessed at the various time points, then arguments <code>type</code> and/or <code>obs</code> (together with argument <code>rho</code>) should be used as needed to differentiate effect sizes corresponding to the different constructs and/or scales.
</p>
</li>
<li><p> Many effect size or outcome measures (e.g., raw or standardized mean differences, log-transformed ratios of means, log risk/odds ratios and risk differences) reflect the difference between two conditions (i.e., a contrast). Within a study, there may be more than two conditions, allowing the computation of multiple such contrasts (e.g., treatment A versus a control condition and treatment B versus the same control condition) and hence corresponding effect sizes. The reuse of information from the &lsquo;shared&rsquo; condition (in this example, the control condition) then induces correlation among the effect sizes.
</p>
<p>To account for this, arguments <code>grp1</code> and <code>grp2</code> should be specified to indicate (within each cluster) which two groups were compared in the computation of each effect size (e.g., in the example above, the coding could be <code>grp1=c(1,2)</code> and <code>grp2=c(3,3)</code>; whether numbers or strings are used as identifiers is irrelevant).
</p>
<p>The degree of correlation between two contrast-type effect sizes that is induced by the use of a shared condition is a function of the size of the groups involved in the computation of the two effect sizes (or, more generally, the inverse-sampling variance weights of the condition-specific outcomes). By default, the group sizes (weights) are assumed to be identical across conditions, which implies a correlation of 0.5. If the group sizes (weights) are known, they can be specified via arguments <code>w1</code> and <code>w2</code> (in which case this information is used by the function to calculate a more accurate estimate of the correlation induced by the shared condition).
</p>
<p>In fact, a contrast-type effect size can be based on a between- or a within-subjects design. When at least one or more of the contrast-type effect sizes are based on a within-subjects design, then <code>time1</code> and <code>time2</code> should be used in combination with <code>grp1</code> and <code>grp2</code> to indicate for each effect size the group(s) and time point(s) involved.
</p>
<p>For example, <code>grp1=c(1,2)</code> and <code>grp2=c(3,3)</code> as above in combination with <code>time1=c(1,1)</code> and <code>time2=c(1,1)</code> would imply a between-subjects design involving three groups where two effect size were computed contrasting groups 1 and 2 versus group 3 at a single time point. On the other hand, <code>grp1=c(1,1)</code> and <code>grp2=c(1,1)</code> in combination with <code>time1=c(2,1)</code> and <code>time2=c(3,1)</code> would imply a within-subjects design where two effect size were computed contrasting time points 2 and 3 versus time point 1 in a single group. Argument <code>phi</code> is then used as above to indicate the autocorrelation of the measurements within groups (i.e., for the within-subjects design above, it would be the autocorrelation between time points 2 and 1 or equivalently, between time points 3 and 2).
</p>
</li></ol>

<p>All of the arguments above can be specified together to account for a fairly wide variety of dependency types.
</p>


<h4>Using the <code>rvars</code> Argument</h4>

<p>The function also provides an alternative approach for constructing the variance-covariance matrix using the <code>rvars</code> argument. Here, one must specify the names of the variables in the dataset that correspond to the correlation matrices of the studies (the variables should be specified as a vector; e.g., <code>c(var1, var2, var3)</code>).
</p>
<p>In particular, let \(k_i\) denote the number of rows corresponding to the \(i\textrm{th}\) cluster. Then the values of the first \(k_i\) variables from <code>rvars</code> are used to construct the correlation matrix and, together with the sampling variances (specified via <code>vi</code>), the variance-covariance matrix. Say there are three studies, the first with two correlated estimates, the second with a single estimate, and the third with four correlated estimates. Then the data structure should look like this:
</p>
<pre>study  yi  vi  r1  r2  r3  r4
=============================
    1   .   .   1  NA  NA  NA
    1   .   .  .6   1  NA  NA
-----------------------------
    2   .   .   1  NA  NA  NA
-----------------------------
    3   .   .   1  NA  NA  NA
    3   .   .  .8   1  NA  NA
    3   .   .  .5  .5   1  NA
    3   .   .  .5  .5  .8   1
=============================</pre>
<p>with <code>rvars = c(r1, r2, r3, r4)</code>. If the <code>rvars</code> variables are a consecutive set in the data frame (as above), then one can use the shorthand notation <code>rvars = c(r1:r4)</code>, so <code>r1</code> denotes the first and <code>r4</code> the last variable in the set. Note that only the lower triangular part of the submatrices defined by the <code>rvars</code> variables is used.
</p>
<p>There must be as many variables specified via <code>rvars</code> as the number of rows in the <em>largest</em> cluster (in smaller clusters, the non-relevant variables can just be set to <code>NA</code>; see above).
</p>



<h3>Value</h3>

<p>A \(k \times k\) variance-covariance matrix, where \(k\) denotes the length of the <code>vi</code> variable (i.e., the number of rows in the dataset).
</p>


<h3>Note</h3>

<p>Depending on the data structure, the specified variables, and the specified values for <code>rho</code> and/or <code>phi</code>, it is possible that the constructed variance-covariance matrix is not positive definite within one or more clusters (this is checked when <code>checkpd=TRUE</code>, which is the default). If such non-positive definite submatrices are found, the reasons for this should be carefully checked since this might indicate misapplication of the function and/or the specification of implausible values for <code>rho</code> and/or <code>phi</code>.
</p>
<p>When setting <code>nearpd=TRUE</code>, the <code><a href="../../Matrix/html/nearPD.html">nearPD</a></code> function from the <a href="https://cran.r-project.org/package=Matrix">Matrix</a> package is used on variance-covariance submatrices that are not positive definite. This should only be used cautiously and after understanding why these matrices are not positive definite.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Viechtbauer <a href="mailto:wvb@metafor-project.org">wvb@metafor-project.org</a> <a href="https://www.metafor-project.org">https://www.metafor-project.org</a>
</p>


<h3>References</h3>

<p>Viechtbauer, W. (2010). Conducting meta-analyses in R with the metafor package. <em>Journal of Statistical Software</em>, <b>36</b>(3), 1&ndash;48. <code style="white-space: pre;">https://doi.org/10.18637/jss.v036.i03</code>
</p>


<h3>See Also</h3>

<p><code><a href="escalc.html">escalc</a></code> for a function to compute the observed effect sizes or outcomes (and corresponding sampling variances) for which a variance-covariance matrix could be constructed.
</p>
<p><code><a href="rcalc.html">rcalc</a></code> for a function to construct the variance-covariance matrix of dependent correlation coefficients.
</p>
<p><code><a href="rma.mv.html">rma.mv</a></code> for a model fitting function that can be used to meta-analyze dependent effect sizes or outcomes.
</p>


<h3>Examples</h3>

<pre>
############################################################################

### see help(dat.assink2016) for further details on this dataset

dat &lt;- dat.assink2016
head(dat, 9)

### assume that the effect sizes within studies are correlated with rho=0.6
V &lt;- vcalc(vi, cluster=study, obs=esid, data=dat, rho=0.6)

### show part of V matrix for studies 1 and 2
round(V[dat$study %in% c(1,2), dat$study %in% c(1,2)], 4)

### or show as list of matrices
blsplit(V, dat$study, round, 4)[1:2]

### use a correlation of 0.7 for effect sizes corresponding to the same type of
### delinquent behavior and a correlation of 0.5 for effect sizes corresponding
### to different types of delinquent behavior
V &lt;- vcalc(vi, cluster=study, type=deltype, obs=esid, data=dat, rho=c(0.7, 0.5))
blsplit(V, dat$study, round, 3)[16]

### examine the correlation matrix for study 16
blsplit(V, dat$study, cov2cor)[16]

############################################################################

### see help(dat.ishak2007) for further details on this dataset

dat &lt;- dat.ishak2007
head(dat, 5)

### create long format dataset
dat &lt;- reshape(dat, direction="long", idvar="study", v.names=c("yi","vi"),
               varying=list(c(2,4,6,8), c(3,5,7,9)))
dat &lt;- dat[order(study, time),]

### remove missing measurement occasions from dat
dat &lt;- dat[!is.na(yi),]
rownames(dat) &lt;- NULL

### show the data for the first 5 studies
head(dat, 8)

### construct the full (block diagonal) V matrix with an AR(1) structure
### assuming an autocorrelation of 0.97 as estimated by Ishak et al. (2007)
V &lt;- vcalc(vi, cluster=study, time1=time, phi=0.97, data=dat)
V[1:8, 1:8]
cov2cor(V[1:8, 1:8])

### or show as a list of matrices
blsplit(V, dat$study)[1:5]
blsplit(V, dat$study, cov2cor)[1:5]

############################################################################

### see help(dat.kalaian1996) for further details on this dataset

dat &lt;- dat.kalaian1996
head(dat, 12)

### construct the variance-covariance matrix assuming rho = 0.66 for effect sizes
### corresponding to the 'verbal' and 'math' outcome types
V &lt;- vcalc(vi, cluster=study, type=outcome, data=dat, rho=0.66)
round(V[1:12,1:12], 4)

############################################################################

### see help(dat.berkey1998) for further details on this dataset

dat &lt;- dat.berkey1998

### variables v1i and v2i correspond to the 2x2 var-cov matrices of the studies;
### so use these variables to construct the V matrix (note: since v1i and v2i are
### var-cov matrices and not correlation matrices, set vi=1 for all rows)
V &lt;- vcalc(vi=1, cluster=author, rvars=c(v1i, v2i), data=dat)
V
round(cov2cor(V), 2)

### or show as a list of matrices
blsplit(V, dat$author, function(x) round(cov2cor(x), 2))

### construct the variance-covariance matrix assuming rho = 0.4 for effect sizes
### corresponding to the 'PD' and 'AL' outcome types
V &lt;- vcalc(vi=vi, cluster=trial, type=outcome, data=dat, rho=0.4)
round(V,4)
cov2cor(V)

############################################################################

### see help(dat.knapp2017) for further details on this dataset

dat &lt;- dat.knapp2017
dat[-c(1:2)]

### create variable that indicates the task and difficulty combination as increasing integers
dat$task.diff &lt;- unlist(lapply(split(dat, dat$study), function(x) {
   task.int &lt;- as.integer(factor(x$task))
   diff.int &lt;- as.integer(factor(x$difficulty))
   diff.int[is.na(diff.int)] &lt;- 1
   paste0(task.int, ".", diff.int)}))

### construct correlation matrix for two tasks with four different difficulties where the
### correlation is 0.4 for different difficulties of the same task, 0.7 for the same
### difficulty of different tasks, and 0.28 for different difficulties of different tasks
R &lt;- matrix(0.4, nrow=8, ncol=8)
R[5:8,1:4] &lt;- R[1:4,5:8] &lt;- 0.28
diag(R[1:4,5:8]) &lt;- 0.7
diag(R[5:8,1:4]) &lt;- 0.7
diag(R) &lt;- 1
rownames(R) &lt;- colnames(R) &lt;- paste0(rep(1:2, each=4), ".", 1:4)
R

### construct an approximate V matrix accounting for the use of shared groups and
### for correlations among tasks/difficulties as specified in the R matrix above
V &lt;- vcalc(vi, cluster=study, grp1=group1, grp2=group2, w1=n_sz, w2=n_hc,
           obs=task.diff, rho=R, data=dat)
Vs &lt;- blsplit(V, dat$study)
cov2cor(Vs[[3]])  # study with multiple SZ groups and a single HC group
cov2cor(Vs[[6]])  # study with two task types and multiple difficulties
cov2cor(Vs[[12]]) # study with multiple difficulties for the same task
cov2cor(Vs[[24]]) # study with separate rows for males and females
cov2cor(Vs[[29]]) # study with separate rows for three genotypes

############################################################################
</pre>

<hr /><div style="text-align: center;">[Package <em>metafor</em> version 3.4-0 <a href="00Index.html">Index</a>]</div>
</body></html>
