<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Fit Regression Models based on Correlation and Covariance...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for matreg {metafor}"><tr><td>matreg {metafor}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Fit Regression Models based on Correlation and Covariance Matrices</h2>

<h3>Description</h3>

<p>Function to fit regression models based on correlation and covariance matrices. <script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
</p>


<h3>Usage</h3>

<pre>
matreg(y, x, R, n, V, cov=FALSE, means, ztor=FALSE,
       nearpd=FALSE, level=95, digits, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y</code></td>
<td>
<p>index (or name given as a character string) of the outcome variable.</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>indices (or names given as a character vector) of the predictor variables.</p>
</td></tr>
<tr valign="top"><td><code>R</code></td>
<td>
<p>correlation or covariance matrix (or only the lower triangular part including the diagonal).</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>sample size based on which the elements in the correlation/covariance matrix were computed.</p>
</td></tr>
<tr valign="top"><td><code>V</code></td>
<td>
<p>variance-covariance matrix of the lower triangular elements of the correlation/covariance matrix. Either <code>V</code> or <code>n</code> should be specified, not both. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>cov</code></td>
<td>
<p>logical to specify whether <code>R</code> is a covariance matrix (the default is <code>FALSE</code>).</p>
</td></tr>
<tr valign="top"><td><code>means</code></td>
<td>
<p>optional vector to specify the means of the variables (only relevant when <code>cov=TRUE</code>).</p>
</td></tr>
<tr valign="top"><td><code>ztor</code></td>
<td>
<p>logical to specify whether <code>R</code> is a matrix of r-to-z transformed correlations and hence should be back-transformed to raw correlations (the default is <code>FALSE</code>). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>nearpd</code></td>
<td>
<p>logical to specify whether the <code><a href="../../Matrix/html/nearPD.html">nearPD</a></code> function from the <a href="https://cran.r-project.org/package=Matrix">Matrix</a> package should be used when the \(R_{x,x}\) matrix cannot be inverted. See &lsquo;Note&rsquo;.</p>
</td></tr>
<tr valign="top"><td><code>level</code></td>
<td>
<p>numeric value between 0 and 100 to specify the confidence interval level (the default is 95).</p>
</td></tr>
<tr valign="top"><td><code>digits</code></td>
<td>
<p>optional integer to specify the number of decimal places to which the printed results should be rounded.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let \(R\) be a \(p \times p\) correlation or covariance matrix. Let \(y\) denote the row/column of the outcome variable and \(x\) the row(s)/column(s) of the predictor variable(s) in this matrix. Let \(R_{x,x}\) and \(R_{x,y}\) denote the corresponding submatrices of \(R\). Then \[b = R_{x,x}^{-1} R_{x,y}\] yields the standardized or raw regression coefficients (depending on whether \(R\) is a correlation or covariance matrix, respectively) when regressing the outcome variable on the predictor variable(s).
</p>
<p>The \(R\) matrix may be computed based on a single sample of \(n\) subjects. In this case, one should specify the sample size via argument <code>n</code>. The variance-covariance matrix of the standardized regression coefficients is then given by \(\mbox{Var}[b] = \mbox{MSE} \times R_{x,x}^{-1}\), where \(\mbox{MSE} = (1 - b'R_{x,y}) / (n - m)\) and \(m\) denotes the number of predictor variables. The standard errors are then given by the square root of the diagonal elements of \(\mbox{Var}[b]\). Test statistics (in this case, t-statistics) and the corresponding p-values can then be computed as in a regular regression analysis. When \(R\) is a covariance matrix, one should set <code>cov=TRUE</code> and specify the means of the \(p\) variables via argument <code>means</code> to obtain raw regression coefficients including the intercept and corresponding standard errors.
</p>
<p>Alternatively, \(R\) may be the result of a meta-analysis of correlation coefficients. In this case, the elements in \(R\) are pooled correlation coefficients and the variance-covariance matrix of these pooled coefficients should be specified via argument <code>V</code>. The order of elements in <code>V</code> should correspond to the order of elements in the lower triangular part of \(R\) column-wise. For example, if \(R\) is a \(4 \times 4\) matrix of the form: \[\begin{bmatrix} 1 & & & \\ r_{21} & 1 & & \\ r_{31} & r_{32} & 1 & \\ r_{41} & r_{42} & r_{43} & 1 \end{bmatrix}\] then the elements are \(r_{21}\), \(r_{31}\), \(r_{41}\), \(r_{32}\), \(r_{42}\), and \(r_{43}\) and hence <code>V</code> should be a \(6 \times 6\) variance-covariance matrix of these elements in this order. The variance-covariance matrix of the standardized regression coefficients (i.e., \(\mbox{Var}[b]\)) is then computed as a function of <code>V</code> as described in Becker (1992) using the multivariate delta method. The standard errors are then again given by the square root of the diagonal elements of \(\mbox{Var}[b]\). Test statistics (in this case, z-statistics) and the corresponding p-values can then be computed in the usual manner.
</p>
<p>In case \(R\) is the result of a meta-analysis of Fisher r-to-z transformed correlation coefficients (and hence <code>V</code> is then the corresponding variance-covariance matrix of these pooled transformed coefficients), one should set argument <code>ztor=TRUE</code>, so that the appropriate back-transformation is then applied to <code>R</code> (and <code>V</code>) within the function.
</p>
<p>Finally, \(R\) may be a covariance matrix based on a meta-analysis (e.g., the estimated variance-covariance matrix of the random effects in a multivariate model). In this case, one should set <code>cov=TRUE</code> and <code>V</code> should again be the variance-covariance matrix of the elements in \(R\), but now including the diagonal. Hence, if \(R\) is a \(4 \times 4\) matrix of the form: \[\begin{bmatrix} \tau_1^2 & & & \\ \tau_{21} & \tau_2^2 & & \\ \tau_{31} & \tau_{32} & \tau_3^2 & \\ \tau_{41} & \tau_{42} & \tau_{43} & \tau_4^2 \end{bmatrix}\] then the elements are \(\tau^2_1\), \(\tau_{21}\), \(\tau_{31}\), \(\tau_{41}\), \(\tau^2_2\), \(\tau_{32}\), \(\tau_{42}\), \(\tau^2_3\), \(\tau_{43}\), and \(\tau^2_4\), and hence <code>V</code> should be a \(10 \times 10\) variance-covariance matrix of these elements in this order. Argument <code>means</code> can then again be used to specify the means of the variables.
</p>


<h3>Value</h3>

<p>An object of class <code>"matreg"</code>. The object is a list containing the following components:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>tab</code></td>
<td>
<p>a data frame with the estimated model coefficients, standard errors, test statistics, degrees of freedom (only for t-tests), p-values, and lower/upper confidence interval bounds.</p>
</td></tr>
<tr valign="top"><td><code>vb</code></td>
<td>
<p>the variance-covariance matrix of the estimated model coefficients.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>some additional elements/values.</p>
</td></tr>
</table>
<p>The results are formatted and printed with the <code><a href="print.matreg.html">print</a></code> function.
</p>


<h3>Note</h3>

<p>Only the lower triangular part of <code>R</code> (and <code>V</code> if it is specified) is used in the computations.
</p>
<p>If \(R_{x,x}\) is not invertible, an error will be issued. In this case, one can set argument <code>nearpd=TRUE</code>, in which case the <code><a href="../../Matrix/html/nearPD.html">nearPD</a></code> function from the <a href="https://cran.r-project.org/package=Matrix">Matrix</a> package will be used to find the nearest positive semi-definite matrix, which should be invertible. The results should be treated with caution when this is done.
</p>
<p>When \(R\) is a covariance matrix with <code>V</code> and <code>means</code> specified, the means are treated as known constants when estimating the standard error of the intercept.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Viechtbauer <a href="mailto:wvb@metafor-project.org">wvb@metafor-project.org</a> <a href="https://www.metafor-project.org">https://www.metafor-project.org</a>
</p>


<h3>References</h3>

<p>Becker, B. J. (1992). Using results from replicated studies to estimate linear models. <em>Journal of Educational Statistics</em>, <b>17</b>(4), 341&ndash;362. <code style="white-space: pre;">https://doi.org/10.3102/10769986017004341</code>
</p>
<p>Becker, B. J. (1995). Corrections to &quot;Using results from replicated studies to estimate linear models&quot;. <em>Journal of Educational and Behavioral Statistics</em>, <b>20</b>(1), 100&ndash;102. <code style="white-space: pre;">https://doi.org/10.3102/10769986020001100</code>
</p>
<p>Becker, B. J., &amp; Aloe, A. (2019). Model-based meta-analysis and related approaches. In H. Cooper, L. V. Hedges, &amp; J. C. Valentine (Eds.), <em>The handbook of research synthesis and meta-analysis</em> (3rd ed., pp. 339&ndash;363). New York: Russell Sage Foundation.
</p>


<h3>See Also</h3>

<p><code><a href="rma.mv.html">rma.mv</a></code> for a function to meta-analyze multiple correlation coefficients that can be used to construct an \(R\) matrix.
</p>
<p><code><a href="rcalc.html">rcalc</a></code> for a function to construct the variance-covariance matrix of dependent correlation coefficients.
</p>


<h3>Examples</h3>

<pre>
### copy data into 'dat'
dat &lt;- dat.craft2003

### construct dataset and var-cov matrix of the correlations
tmp &lt;- rcalc(ri ~ var1 + var2 | study, ni=ni, data=dat)
V &lt;- tmp$V
dat &lt;- tmp$dat

### turn var1.var2 into a factor with the desired order of levels
dat$var1.var2 &lt;- factor(dat$var1.var2,
   levels=c("acog.perf", "asom.perf", "conf.perf", "acog.asom", "acog.conf", "asom.conf"))

### multivariate random-effects model
res &lt;- rma.mv(yi, V, mods = ~ var1.var2 - 1, random = ~ var1.var2 | study, struct="UN", data=dat)
res

### restructure estimated mean correlations into a 4x4 matrix
R &lt;- vec2mat(coef(res))
rownames(R) &lt;- colnames(R) &lt;- c("perf", "acog", "asom", "conf")
round(R, digits=3)

### check that order in vcov(res) corresponds to order in R
round(vcov(res), digits=4)

### fit regression model with 'perf' as outcome and 'acog', 'asom', and 'conf' as predictors
matreg(1, 2:4, R=R, V=vcov(res))

### can also specify variable names
matreg("perf", c("acog","asom","conf"), R=R, V=vcov(res))

## Not run: 
### repeat the above but with r-to-z transformed correlations
dat &lt;- dat.craft2003
tmp &lt;- rcalc(ri ~ var1 + var2 | study, ni=ni, data=dat, rtoz=TRUE)
V &lt;- tmp$V
dat &lt;- tmp$dat
dat$var1.var2 &lt;- factor(dat$var1.var2,
   levels=c("acog.perf", "asom.perf", "conf.perf", "acog.asom", "acog.conf", "asom.conf"))
res &lt;- rma.mv(yi, V, mods = ~ var1.var2 - 1, random = ~ var1.var2 | study, struct="UN", data=dat)
R &lt;- vec2mat(coef(res))
rownames(R) &lt;- colnames(R) &lt;- c("perf", "acog", "asom", "conf")
matreg(1, 2:4, R=R, V=vcov(res), ztor=TRUE)

## End(Not run)

############################################################################

### a different example based on van Houwelingen et al. (2002)

### create dataset in long format
dat.long &lt;- to.long(measure="OR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.colditz1994)
dat.long &lt;- escalc(measure="PLO", xi=out1, mi=out2, data=dat.long)
dat.long$tpos &lt;- dat.long$tneg &lt;- dat.long$cpos &lt;- dat.long$cneg &lt;- NULL
levels(dat.long$group) &lt;- c("CON", "EXP")

### fit bivariate model
res &lt;- rma.mv(yi, vi, mods = ~ group - 1, random = ~ group | trial, struct="UN",
              data=dat.long, method="ML")
res

### regression of log(odds)_EXP on log(odds)_CON
matreg(y=2, x=1, R=res$G, cov=TRUE, means=coef(res), n=res$g.levels.comb.k)

### but the SE of the CON coefficient is not computed correctly, since above we treat res$G as if
### it was a var-cov matrix computed from raw data based on res$g.levels.comb.k (= 13) data points

### fit bivariate model and get the var-cov matrix of the estimates in res$G
res &lt;- rma.mv(yi, vi, mods = ~ group - 1, random = ~ group | trial, struct="UN",
              data=dat.long, method="ML", cvvc="varcov", control=list(nearpd=TRUE))

### now use res$vvc as the var-cov matrix of the estimates in res$G
matreg(y=2, x=1, R=res$G, cov=TRUE, means=coef(res), V=res$vvc)
</pre>

<hr /><div style="text-align: center;">[Package <em>metafor</em> version 3.4-0 <a href="00Index.html">Index</a>]</div>
</body></html>
